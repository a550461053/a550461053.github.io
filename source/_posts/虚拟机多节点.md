---
title: 虚拟机多节点
date: 2017-12-21 10:39:35
tags: [vmware, ethereum, hyperledger]
---


## vmware配置
- 安装vm12:
	- 安装vmwaretools
		- 点击install tools
		- 解压到桌面
		- 进入
		- sudo ./vmware-install.pl -d
		- 重启
		- 如要卸载: ./vmware-tools-distrib/bin/vmware-uninstall-tools.pl
	- 修改下载源
	- 先用nat模式联网(可以ipv6地址修改，桥接到有线网卡也可以，直接桥接就不需要改ipv6的，vmware支持ipv6自动获取，只需要自该ipv6-nat选项即可), 下载安装各种软件
		- sudo mkdir -p /home/yuziqi/.../github.com
	- 再用桥接模式与宿主机构成局域网, 调试
		- 注意桥接模式选择的网卡是本地有线enp4s0f1还是无线wlp3s0
	- 安装wm12:
		+ vmware10 在linux下有点问题
	- gcc>5.0支持下, 打开前: sudo vmware-modconfig --console --install-all，不执行第一次打开的时候也会自动安装
	- 有时候是内核问题：安装相应的images和headers
	- 卸载：
		+ sudo ./VMware-workstation-Full-9.0.0.bundle --uninstall-product vmware-workstation
		+ 或者：sudo vmware-installer -u vmware-workstation
	- 开启VT：
		+ 重启进入BIOS
		+ 进入config-CPU，有两项虚拟化技术VTx 和 定向IO(VTd)虚拟化技术 改为enable
		+ F10保存并重启
	- 联网考虑因素：
		+ vmware软件配置：
			* 是否连接nat/bridge
			* 是否正确选择bridge的宿主机网卡
		+ 虚拟的系统是否配置正确
		+ 宿主机系统考虑：
			* 是否开启DHCP、NAT服务等
	- windows下联网：
		+ 记得开启服务：VMware DHCP和VMware NAT两个服务
			* win+r -> services.msc
			* 如果需要还得打开usb服务！
		+ 记得打开vmware右下方的nat服务连接！！
		+ 记得选择vmware的同步时间选项
- Ubuntu出现引导错误，进入grub：
	+ 用U盘进入试用模式
	+ sudo su
	+ sudo add-apt-repository ppa:yannubuntu/boot-repair
	+ apt-get update
	+ apt-get install boot-repair
	+ 在dash中搜索boot-repair
	+ 点recommand repair
- 虚拟机复制出现grub问题：
	+ 当系统装了多个内核之后，开机就会进入grub，需要找到内核启动
	+ 查看分区：ls
	+ 查看系统所在分区：ls (hd0,msdos1)
	+ 找到启动分区：
		* root=(hd0,msdos1)
		* prefix=/boot/grub
		* set root=(hd0,msdos1)
		* set prefix=(hd0,msdos1)/boot/grub
		* 启动：insmod normal
		* normal
		* 正常应该会进入Ubuntu命令行的，按c，但我没有进去
	+ 设置内核：
		* linux /vmlinux-xxx-xxx root=/dev/sda1
		* initrd /initrd.img-xxx-xxx
		* 启动：boot
	+ 进入到Ubuntu修复grub：
		* sudo update-grub
		* sudo grub-install /dev/sda # 不要指定sda1
	+ ok
	+ 如果grub都不行，则可以选择从ios进入try Ubuntu修复grub
		* sudo fdisk -l
		* 挂载所在系统盘：sudo mount /dev/sda1 /mnt
		* 开始恢复引导系统：sudo grub-install --root-directory=/mnt /dev/sda # 不要指定sda1
- vmware多节点
	+ 计划布置：
		+ orderer1.org1.batista.com - 192.168.1.2
		+ peer0.org1.batista.com - 192.168.1.11
		+ peer1.org1.batista.com - 192.168.1.12 
		+ peer0.org2.batista.com - 192.168.1.13
		+ peer1.org2.batista.com - 192.168.1.14
	+ 修改hostname：
		* batista@ubuntu: 前者是用户名，Ubuntu才是主机名
		* 临时：hostname vm1 # 重启会恢复
		* 永久：
			- /etc/hostname 
			- /etc/hosts # 修改127.0.0.1 localhost  # 就是DNS
				+ 192.168.
			- 改完之后得重启生效，所以用一次临时的即可
			- 改为orderer1.org1.batista.com,可能显示有问题，但是还是修改了。
	+ docker0网桥：
		* 其他的网桥上的网卡，在docker容器结束后正常是应该会消失的
		* 停止: ifconfig docker0 down
		* 删除：brctl delbr docker0
		* 查看所有网桥：brctl show
	+ 配置vmware网桥：
		* 选择桥接，若选择复制物理连接状态，则在有线无线进行切换的时候，IP地址会自动更新，适合笔记本电脑上运行的虚拟机。
		* 高级选项选择：traffic 流入流出的带宽限制，都给了4Mbps限制
		* 会占用10.10.28.102的局域网端口，so换方法
		* 将主机联入路由器的局域网中192.168.1.1
		* 再进行桥接
		* 联入路由器的局域网，电脑端必须自动获取IP，要想设置静态IP，在路由器端进行DHCP服务器配置相应mac机器即可。
	+ vmware虚拟机克隆或复制：
		* 复制后打开有两种方式：
			- i copy id：这样会检测物理机改变后，重新生成一个新的网卡mac地址
			- i move it：这样知道了只是移动了这个虚拟机，只有uuid.location发生变化，mac地址不变
		* mac复制或clone后改变：
			- 但是路由器已经修改了mac绑定静态DHCP ip，为了简单
			- 直接使用Ubuntu的clone mac功能，clone mac为之前已经在路由器中设定的mac
		* 可以手动修改物理网卡mac：
			- 方法一：直接编辑*.vmx文件，类似于重新烧录了vmware虚拟机的物理网卡ROM：
				+ 查看后，发现ethernet0.addressType="static" 或 "vpx"
				+ 说明是静态设定的，修改为以00:50:56开头的另一个mac即可
				+ 改完后重启vm时，若问你SSID的话，选择"keepalways"
			- 方法二：发现是ethernet0.addressType="generated"
				+ 说明vm的物理网卡的mac是随系统随机动态指定的，可以通过将uuid.bios后六位及ethernet0.generatedAddress后六位改为想要的以00:0c:29
	+ 配置vmware-nat方式：
		* vmnet8
		* gateway：192.168.93.2, mask:255.255.255.0
		* 多节点之间不能互相ping通

- vmware的ip设置：
	+ 如果需要虚拟机和宿主机同一ip，则：桥接模式，并选择复制物理网络连接状态
	+ Bridge桥接：“网络桥接”中的“直接桥接到物理网络”意思是重新分配一个 IP地址。而“复制物理网络连接状态”就是虚拟机和本地电脑通用一块网卡。 也就不存在重新为虚拟机上网分配IP地址。

- vmware扩容，扩大硬盘
	+ 扩展硬盘，提示无法扩展，需要删除快照：删除所有快照
	+ 扩展硬盘，后df看不出来，虚拟机暂时没有识别
	+ 分区：
		* 正常进入系统，然后init 1，进入到单用户模式，crtl+alt+f1，登录root用户
		* fdisk -l /dev/sda 查看磁盘分区情况
		* fdisk /dev/sda 进入到fdisk磁盘管理
		* 输入：n {new partition}
		* 输入：p {primary partition}
		* 输入分区号：3 {partition number}表示第三个
		* first sector选择默认即可
		* last sector：可以使用+30G来表示，或者仔细计算：一个sector=512字节=0.5kb，所以50G=1024*1024*2*50-1
		* partprobe更新分区
		* 关闭tty7的图形界面占用，ligthdm服务，可以在终端输入：
			- systemctl disable lightdm.service
			- 或：/etc/init.d/lightdm stop
			- 开启：/etc/init.d/lightdm start
	+ 挂载：
		* swap不需要挂载
		* 将刚创建的新的分区3挂载到目录上之前，需要格式化
			- mkfs.ext4 /dev/sda2
		* 挂载到一个准备好的空目录上
			- mkdir /home/batista/disk1 -p
			- mount /dev/sda2 /home/batista/disk1
		* 设置开机自动挂载
			- vim /etc/fstab
			- 添加一行：/dev/sda2 /home/batista/disk1 ext4 defaults 0 2
		* df -h 查看最后的结果

## 多节点环境搭建-ethereum

- 虚拟机安装geth:
	- 更新本机软件: sudo apt update; sudo apt -f install 
	- git: git --version: 2.7.4
	- nodejs: nodejs -v
		- Linux中node是另一个软件,需要安装插件来修改node命名
		- 若要使用node -v: sudo apt install nodejs-legacy
	- npm: npm -v
	- go1.7: go version
	- geth: 
		- 复制go-ethereum文件夹到虚拟机
		- cd go-ethereum
		- make geth
		- ./build/bin/geth
	- mist
		- 
	- 测试:
		- 虚拟机桥接模式: ip 10.10.28.102 // ip 124.16.90.2
		- git clone https://github.com/ethereum/go-ethereum
		- cd go-ethereum; make geth
		- gedit init.json
'''
{
  "nonce": "0x0000000000000042",
  "difficulty": "0x400",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "timestamp": "0x00",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x1388",
  "alloc": {
  },
  "config": {
        "chainId": 15,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    }
}
'''
	- 先删除之前的.app 和 .ethash, 然后: ./geth --datadir "~/app/chain" init init.json
	- 启动网络: ./geth --rpc --rpccorsdomain "*" --ipcpath "~/app/chain/geth.ipc" --datadir "~/app/chain" --port "30303" --rpcapi "db,eth,net,web3" --networkid 100000 console

	- 虚拟机: "enode://3519f8ae9f7492be1b2fa479456f0c156e5e969128d8207a678b1d1a6982eb4130c5f46adb099219d2e0d2435b739b346f4b0f7512993a23998e45d39bd13f9c@192.168.1.101:30303"
	- 虚拟机: 124.16.90.2
	- 宿主机: admin.addPeer("enode://3519f8ae9f7492be1b2fa479456f0c156e5e969128d8207a678b1d1a6982eb4130c5f46adb099219d2e0d2435b739b346f4b0f7512993a23998e45d39bd13f9c@124.16.90.2:30303")

	- 虚拟机初始化: ./geth  --datadir "~/app/chain" init init.json
	- 虚拟机以太坊启动:
	- ./geth --rpc --rpcport 8545 --rpccorsdomain "*" --rpcapi "db,eth,net,web3" --ipcpath "~/app/chain/geth.ipc" --datadir "~/app/chain" --port "30303" --networkid 100000 console
	- networkid 100001每个node的id相同
	- 查看虚拟机node URL: admin.nodeInfo.enode
	"enode://8407de28f331c070491f85afd4112a8e71ba150f6b980e599e6cbe1216f899cef554e923a3f148c2feda1db12f0ea1355039775ad9cf9e61ca3a4b20d3ca682e@[::]:30303"
	- 宿主机以太坊启动: 同样的命令networkid 100000
	- 宿主机添加node: admin.addPeer("enode://e8aabbc3aa45dc38492f8c406c311dae3eb6c7771275a9279a158534169d52fd28a64771e60fcc9a9691478ac438fc7fe7dc13eb1a35480a98d8014e6925f3c5@[192.168.1.187]:30303")
		- 查看节点: admin.peers
		- 这种方法太慢, 同步要好久
	- 导出区块链:
		- 宿主机: geth export filename
		- 虚拟机: geth import filename
	- 同步虚拟机时间: 
		- 修改为上海时区
	 	- apt-get install ntp
		- /etc/init.d/ntp start


## 任务
智能合约是如何在两个节点存的
数据是如何存的
两个节点如何协作

宿主机A: 添加两个用户, 户0给用户1转账:
	- 用户0先挖矿, 赚足够支付的钱: miner.start()
	- eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(0.001, "ether"), gas:30000})
	- gas:
		- 0.001 需要 21000gas
		- 0.006 需要 121000gas
		- 每million 的gas , 0.05ether
		- gas要大于默认的交易gas: 21000
		- init.js中的gaslimit默认是0x1388(5000), 改为0xC350(50000), 或者0xffffffff
		- truffle工程的truffle.js的network的gas:500000,改大点

虚拟机: miner.start()
宿主机: 检查余额: eth.getBalance(eth.accounts[1]), 交易成功

- 单机运行测试:
	- 

参见：https://sanwen8.cn/p/3dcX1wi.html


## 多节点实验-ethereum

A节点: miner: "0x2e7ac7512a1c95b395141a6181623bbf36f0b8a5"
B节点:
C节点: 
A连接B, B连接C

A节点 miner.start():
	epoch0 generating DAG in progress: 2m41.549s
	generated ethash verification cache: 32.762s
	epoch1 generating DAG  in progress: 17m14.1

INFO [08-18|14:16:44] Commit new mining work                   number=243 txs=0 uncles=0 elapsed=180.33µs
INFO [08-18|14:16:44] Successfully sealed new block            number=243 hash=fc683a…10a59c
INFO [08-18|14:16:44] 🔗 block reached canonical chain          number=238 hash=b6e0d5…f3e8e5
INFO [08-18|14:16:44] 🔨 mined potential block                  number=243 hash=fc683a…10a59c

A节点 eth.sendTransaction({from:eth.accounts[0], to:eth.accounts[1], value:web3.toWei(5, 'ether')}):
	INFO [08-18|14:22:58] Submitted transaction                    fullhash=0x62630d496193253e55af0ea47c0e5d4d787f7b232e0997a8a10fb9e548deb54f recipient=0x48ca728ecccafd114ec769860373fc47671778cf
	"0x62630d496193253e55af0ea47c0e5d4d787f7b232e0997a8a10fb9e548deb54f"
	
miner.start(2);admin.sleepBlocks(1);miner.stop();	

通过终端调用智能合约:
abi=[{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"set","outputs":[],"payable":false,"type":"function"}]
address="0x91ee6082c09c72d7de14682b027f6fcdeb162c6b"
g=eth.contract(abi).at(address)
g.get()
g.set({from:eth.accounts[0]})
注意: 当调用set()的时候, 任何修改合约状态的操作都需要用户来签名交易


- 测试shh发送message
	+ 见: https://github.com/ethereum/go-ethereum/wiki/Whisper-Usage
./geth --shh  --rpc --rpccorsdomain "*" --ipcpath "~/app/chain/geth.ipc" --datadir "~/app/chain" --port "30303" --rpcapi "db,eth,net,web3,shh" --networkid 100000 console
shh.version
shh.info()
shh.setMaxMessageLength(999999) // 设置最大消息长度
shh.setMinimumPoW(2.12) //设置最小所需要的PoW
shh.allowP2PMessagesFromPeer("enode://d25474361659861e9e651bc728a17e807a3359ca0d344afd544ed0f11a31faecaf4d74b55db53c6670fd624f08d5c79adfc8da5dd4a11b9213db49a3b750845e@52.178.209.125:30379") // 允许发送历史消息
shh.hasKeyPair("5e57b9ffc2387e18636e0a3d0c56b023264c16e78a2adcba1303cefc685e610f") // 是否有该PK的私钥
shh.deleteKeyPair("5e57b9ffc2387e18636e0a3d0c56b023264c16e78a2adcba1303cefc685e610f") // 删除key
var key = shh.newKeyPair() // 创建一个加密标识ID号, 用来加密message, 
shh.getPublickey(key) // 返回值是ID的PK
shh.getPrivateKey(key) // 返回值是ID的私钥
shh.generateSymmetricKey() // 产生一个随机的对称key
shh.addSymmetricKeyDirect(private_key) // 保存私钥, 返回ID
shh.addSymmetricKeyFromPassword("test") 
shh.getSymmetricKey(key_ID) // 输入key的ID, 返回对称key
shh.hasSymmetricKey() // 
shh.deleteSymmetricKey("f6dcf21ed6a17bd78d8c4c63195ab997b3b65ea683705501eae82d32667adc92")

shh.getNewSubscriptionMessages("02c1f5c953804acee3b68eda6c0afe3f1b4e0bec73c7445e10d45da333616412")
shh.getFloatingMessages("02c1f5c953804acee3b68eda6c0afe3f1b4e0bec73c7445e10d45da333616412")
shh.subscribe({type: 'asym', pow: 12.3, topics: ['0x5a4ea131', '0x11223344'], key: 'b874f3bbaf031214a567485b703a025cec27d26b2c4457d6b139e56ad8734cea', sig: '0x048229fb947363cf13bb9f9532e124f08840cd6287ecae6b537cda2947ec2b23dbdc3a07bdf7cd2bfb288c25c4d0d0461d91c719da736a22b7bebbcf912298d1e6'})
shh.unsubscribe("02c1f5c953804acee3b68eda6c0afe3f1b4e0bec73c7445e10d45da333616412")
shh.post({type: 'asym', ttl: 7, topic: '0x07678231', powTarget: 2.01, powTime: 2, payload: '0x68656c6c6f', key: '0x048229fb947363cf13bb9f9532e124f08840cd6287ecae6b537cda2947ec2b23dbdc3a07bdf7cd2bfb288c25c4d0d0461d91c719da736a22b7bebbcf912298d1e6'})
subscribe: 格式:
	type       string
	key        string
	sig        string
	minPoW     float64
	topics     [][]byte
	allowP2P   bool
其中: type只能是sym或者asym
Post: 格式:
	type       string
	ttl        uint32
	sig        string
	key        string
	topic      [4]byte
	padding    []byte
	payload    []byte
	powTime    uint32
	powTarget  float64
	targetPeer string

- test the Whisper node on private network

geth --shh --testnet --nodiscover console
利用已有测试节点: enode://d25474361659861e9e651bc728a17e807a3359ca0d344afd544ed0f11a31faecaf4d74b55db53c6670fd624f08d5c79adfc8da5dd4a11b9213db49a3b750845e@52.178.209.125:30379
admin.addPeer("enode://d25474361659861e9e651bc728a17e807a3359ca0d344afd544ed0f11a31faecaf4d74b55db53c6670fd624f08d5c79adfc8da5dd4a11b9213db49a3b750845e@52.178.209.125:30379")


use cases: geth 1.6.1之后 Whisper v2升级为 v5版本, shh.newIdentity()函数被替换为subscribe

1. 接收非对称加密信息: 
id = shh.newKeyPair()
pk = shh.getPublicKey(id) // 取出PK
f = shh.subscribe({type: 'asym', key: id}) //创建消息, 返回消息的ID
广播PK: 
轮寻消息: shh.getNewSubscriptionMessages(f)
发送非对称加密: shh.post({type: 'asym', ttl: 7, powTarget: 2.5 powTime: 2, payload: '0x7777777777777777', key: pk})

2. 接收对称加密信息: 共享相同的对称key
id = shh.addSymmetricKeyFromPassword('test') // 更新为:id = shh.generateSymKeyFromPassword('test')
f = shh.subscribe({type: 'sym', topics: ['0x07678231'], key: id})
接收: shh.getNewSubscriptionMessages(f)
发送: shh.post({type: 'sym', ttl: 7, topic: '0x07678231', powTarget: 2.01, powTime: 2, payload: '0x68656c6c6f', key: id})
签名: s = shh.newKeyPair()
shh.post({sig: s, type: 'sym', ttl: 7, topic: '0x07678231', powTarget: 2.01, powTime: 2, payload: '0x68656c6c6f', key: id})

3. 一次性会话聊天
id_key = shh.newSymKey() //产生对称秘钥
key = shh.getSymKey(id_key) //取回对称秘钥
id = shh.addSymKey(key) // 目标peer安装秘钥
f = shh.newMessageFilter({type:topics:['0x07678231'], symKeyID: id}) // 所有参与节点都要subscribe这条消息, 
shh.getFilterMessages(f) //正常轮训保存的subscribe的ID



## mist 测试使用

官网钱包dapp: https://wallet.ethereum.org/
Dapp:
Mist是一个去中心化应用浏览器。Mozilla火狐或者谷歌Chrome适用于web 2.0，而Mist浏览器适用于web 3.0而生（3.0时代将会是去中心化的）。
你可以用用Mist浏览器打开任何Ethereum去中心化应用。Ethereum Wallet DApp只是一个以太坊钱包应用
以太坊客户端默认启动连接的节点数位11-13个，如果觉得不够，可以使用在启动时增加启动参数 –maxpeers 100命令，让连接启动节点数增加到100上限，当然，也会大量消耗你的硬盘和CPU。

测试：宿主机节点运行dapp, 其他节点或者任意的浏览器都可以运行dapp：
	但是我测试的是虚拟机节点，虚拟机节点本身有geth客户端，
	不过好像当时没有启动geth，还是能运行dapp。
	但我好像只是利用了打开网页的功能，并没有测试是否能够发起一笔交易，
	不过也应该能够通过宿主机节点发起交易。
	也就是说能够通过web2的浏览器打开dapp，而不是必须得需要web3支持的mist浏览器。
	那么这样的话，开发人员就需要把这个dapp通过应用市场卖给用户，用户再来使用dapp那就是在本地运行自己的节点。


## p2p浏览器文件共享
git clone https://github.com/Peer5/ShareFest.git
cd ShareFest
修改package.json把express改为>=3.0 <4.0
npm install --dedupe 
npm start 
打开网页: localhost:13337


## 测试多节点
如果一个主机开多个VM虚拟机，需要：
	CPU：单核性能强劲；多核心
	内存：足够用
	硬盘：一个硬盘顶多4个虚拟机，是最大的瓶颈，机械硬盘的4K随机读写瓶颈很大，miner开启后，硬盘处于100%读写占用，无法流畅运行主机的物理机；换固态
	显卡：没有影响，VM显卡都是靠CPU模拟出来的
1. 配置: 
	- sublime 安装:ethereum-solidity包
	- remix: 提供在线编译和虚拟机测试运行

2. ethereum P2P:
	- 每个客户端都会有3个硬编码的bootnodes
	- 之间的发现和对等广播基于RLPx的 Kademlia DHT
	- 节点会有一个nodeID: 唯一标示
	- 
3. 最新whisper例子:
	- status: https://github.com/status-im/status-go/blob/3d7f4a3a9653b45a1b66390c727ceec9f79ed924/static/tests/whisper.js
	- https://gist.github.com/rgeraldes/1aa4a4bcdae03d1d79ca02d4ce0fd0b1
	- 最新v5-API: https://github.com/ethereum/go-ethereum/wiki/Whisper-v5-RPC-API

4. 使用curl测试:
'''
geth --shh --testnet --nodiscover --rpc --rpccorsdomain "http://localhost:3000" --shh console

curl -X POST http://localhost:8545 --data '{"jsonrpc":"2.0","method":"shh_subscribe","params":["messages", {
curl -X POST http://localhost:8545 --data '{"jsonrpc":"2.0","method":"shh_subscribe","params":["messages", {
  topics: ['0x5a4ea131', '0x11223344'],
  symKeyID: 'b874f3bbaf031214a567485b703a025cec27d26b2c4457d6b139e56ad8734cea',
  sig: '0x048229fb947363cf13bb9f9532e124f08840cd6287ecae6b537cda2947ec2b23dbdc3a07bdf7cd2bfb288c25c4d0d0461d91c719da736a22b7bebbcf912298d1e6',
  pow: 12.3(?)
  }],"id":1}'

curl -X POST http://localhost:3000 --data '{"jsonrpc":"2.0","method":"shh_post","params":[{
  pubKey: 'b874f3bbaf031214a567485b703a025cec27d26b2c4457d6b139e56ad8734cea',
  ttl: 7,
  topic: '0x07678231',
  powTarget: 2.01,
  powTime: 2,
  payload: '0x68656c6c6f'
  }],"id":1}'
'''

## 综述-架构防御
0. 初始化
	- 设备的出厂ID号经过hash作为device_ID, 用于与hub通信的安全令牌
		- 设备的唯一性标识没有规律, 随机的
	- 每个用户都有一个以太坊账号user_ID
	- 每个hub节点有一个hub_ID
		- admin.node_info
	- 绑定:
		- 每个用户与其对应的hub节点
		- 每个hub节点与其对应的设备
		- 绑定过程为初始化过程, 需要由该hub_ID的用户发起交易完成操作, 无法修改;
		- 若后期需要添加, 删除, 修改绑定关系, 同样需要该hub_ID的用户才能发起交易
		- 设计访问权限:
			- 只有该hub_ID的用户才能访问该homegroup[]变量
			- 对device_ID和hub_ID进行隐匿, 设为private变量
		typedef HomeState struct {
			user_ID,
			hub_ID[],
			device_ID[],
		}
		contract Smarthome {
			HomeState homegroup[];
			init(){
				homegroup[user_ID] = { ... };
			}
		}
	- 控制
		- 威胁: 可非法控制未绑定的设备
	- 授权	
		- 威胁: 
			- 重复绑定, 不用提示原绑定者授权
			- 具体实施: 获取另一个用户的设备, 并通过自己用户的smart登录, 重新初始化自己的合约变量
		- 应对:
			- 首先需要非法获取用户的device,然后用自己的smart对该device操作
			- 智能合约的安全策略限制每个用户的访问权限
			- 需要重新用另一个user_ID登录并发起交易, gas
			- 增加闭环的操作:
				- 每个hub会读取区块链的合约状态变量
				- 若发现设备的状态发生改变, 或者准备执行未授权的动作, 则向用户发送警告.
业务层接入协议的安全威胁:
	1）窃听攻击：
		- 威胁: 
			- 攻击者通过窃听网络通信链路上的数据，获取智能设备终端的隐私数据和敏感数据。例如，通过被动窃听网络可以获取健康医疗类智能硬件设备的数据，从而获得用户的隐私数据。
			- 具体实施: 
		- 应对: 
			- 数据
	2）篡改攻击：攻击者通过主动插入到通信链路上，对数据的完整性进行攻击，即篡改数据报文的内容，例如，攻击者可以篡改智能设备向业务云提交的业务数据，向业务云提供错误的数据信息；
	3）伪造攻击：即一种针对真实性的攻击，攻击者伪造一些看似来自合法来源的数据报文，以此诱骗通信的另一方。尤其是在智能设备的控制指令传输过程中，攻击者可以伪造一些携带控制指令的报文发给智能设备，从而达到未授权操作的效果。
	4）重放攻击：从目前的分析来看，重放攻击主要分为两个方面，一个是针对未加密的通信协议重放控制指令攻击设备，另一个是对会话令牌的重复使用而发起的攻击行为。

1. DDOS防御:
	1. 带外: 网络中的设备是独立于路由器的, 路由器负责传输来自互联网的流量数据, 然后发送元数据样本, 向设备描述流量数据的内容;
		- 如果系统检测到了可疑的数据包或探测到了DDOS攻击的苗头, 那么立即向用户发出警报
		- 特点: 
			- 允许安全人员不影响数据流通信的情况下对流量进行更加复杂的分析, 但是检测到攻击和防御实施之间还有延迟
			- 较慢
	2. 带内: 直接面对所有的通信数据流, 并在对流量分析处理的过程中, 判断那些数据包应该丢弃, 然后将有效的数据包发送给终端用户或设备
	3. 内联系统: 可以查看从某个网络节点流向另外一个网络节点的通信流量, 并且可以实时过滤和处理这些流量.
		- 相对而言: 带外设备几乎无法获取通信流量的样本, 而且数据早就到达目的地址.
		- 特点: 
			- 
	4. 其他:
		- 内容分布网络(CDN)和流量过滤功能，他们会对网络通信流量进行过滤，并且将最终的数据发送给你
	5. IoTPOT:
		- 用户IoT设备的蜜罐: 模拟各种IOT设备的特点欺骗攻击者


## hyperledger

1. docker
	- docker --version # 17.03.0-ce or greater
	- docker-compose --version # 1.8 or greater
	- 删除images：docker rmi -f imagesid
2. go
	- go version: 1.7.x 
3. nodejs
	- sudo apt install nodejs
	- nodejs -v # 才是4.2.6
	- 更新nodejs
		* sudo npm install -g n 
		* sudo n stable ; 更新到7.6.0
		* sudo n 7.6.0 ; 切换到7.6.0
		* node -v ; 显示7.6.0
	- node -v: 6.9.x or greater
4. npm：
	- sudo npm install npm@3.10.10 -g
	- npm -v	
5. fabric源码：
	- go get github.com/hyperledger/fabric 
	- git checkout -b v1.0.0 # 切换到1.0.0版本
	- 后来又改为git checkout -b v1.1.0-preview
6. fabric镜像：
	- 测试fabric集群方案，最简单测试：./fabric/examples/e2e_cli/download-dockerimages.sh
	- 最好使用特定方案下载镜像：
hyperledger/fabric-tools
hyperledger/fabric-orderer
hyperledger/fabric-peer
hyperledger/fabric-couchdb
hyperledger/fabric-kafka
hyperledger/fabric-ca
hyperledger/fabric-ccenv
hyperledger/fabric-baseimage
fabric-baseos：fabric-baseos：x86_64-v0.3.1
fabric-membersrvc ： membersrvc
fabric-javaenv：
fabric-zookeeper：fabric-zookeeper:x86_64-1.0.0
	- docker pull hyperledger/fabric-tools:x86_64-1.0.0
	- docker tag 0403fd1c72c7 docker.io/hyperledger/fabric-tools:latest
	- 删除：docker rmi 0403fd1c72c7
7. 单机example测试：
	- fabric-samples: git clone fabric-samples
		+ cd fabric-samples ; 下载bin文件到fabric-samples
		+ bin文件下载速度很慢，需要离线下载，查看/hyperledger/fabric/scripts/bootstrap-1.0.0.sh的文件
		- 初始化网络：./byfn.sh -m generate
		- 启动网络：./byfn.sh -m up
	- e2e_cli测试：本机运行4+1个fabric网络
		+ cd example/e2e_cli
		+ . download...sh -c x86_64-1.1.0-preview -f x86_64-1.1.0-preview
		+ . network_setup.sh up
		+ . network_setup.sh down
		+ 
	- example02可以看到每一步的操作
8. 多机测试：
	- 生成公私钥、证书、创世区块等
		+ server与server之间安全通信
		+ 创建channel就需要创世区块：
			- examples/e2e_cli/generateArtifacts.sh mychannel
			- 在任意一个节点的该目录下运行此命令即可，将会生成两个目录：
				+ channel-artifacts
				+ crypto-config
	- 配置多服务器：
		+ 在任意一个节点运行：generateArtifacts.sh mychannel
		+ 把生成的两个目录复制到其他服务器相同的e2e_cli目录下
	- 配置docker-compose文件：
		+ cp docker-compose-cli.yaml docker-compose-peer.yaml
		+ 修改docker-compose-peer.yaml，去掉orderer的配置，只保留一个peer和cli
		+ 修改容器的host文件，也就是extra_hosts设置，名字自己命名：
			- peer下面："orderer.example.com:192.168.17.1"
			- cli下面："orderer.example.com:192.168.17.1"
				+ "peer1.org1.example.com:192.168.17.2"
			- 每个peer会有一个对应的客户端，就是cli
		+ 修改端口映射：
			* 单机模式下，4个peer会映射主机不同的端口，但是多机部署的时候不需要映射不同的端口，所以需要修改base/docker-compose-base.yaml文件：ports：7051:7051
	- order节点的docker-compose文件：


## 路由器系统
1. 安装openwrt
2. openwrt网络配置
3. openwrt安装docker
	- docker安装条件：
		+ docker目前只支持64位CPU架构的计算机上运行，x86_64、amd64
		+ linux3.8 或 更高版本的内核，3.8之前的也可以，只是效果不同
		+ 内核必须支持一些合适的存储驱动：
			* Device Manage
			* AUFS
			* vfs
			* btrfs
			* 默认存储驱动通常是device
		+ 内核必须支持并开启cgroup和命名空间namesapce功能
4. 路由


## hyperledger + composer配置多节点
1. 虚拟机：
2. 
